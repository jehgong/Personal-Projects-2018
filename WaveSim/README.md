# Fluid Wave Simulator (WaveSim)
[![WaterSim](https://img.youtube.com/vi/idXoFKszqLw/0.jpg)](https://www.youtube.com/watch?v=idXoFKszqLw)

# Technical Approach

Realistic computer generated ocean surfaces have been used routinely in film features and were basically ported to video games. The algorithm for these surfaces historically used FFT to craft random noise that evolves over time. These algorithms, however, did not give interactivity between objects and the water’s surface. It would be difficult, for example, to have characters wade through a stream and generate a disturbance that depends directly on the motion that the player controls, as this would cause significant FPS lag using FFT. We used the iWave algorithm, which amounts to a two dimensional convolution and some masking operations. The algorithm is efficient because these operations are suitable for hardware acceleration. We see in the results that the waves generated are affected by the speed of mouse movement.

What makes this part of the project unique is its interactivity and realistic variable response to different interactions (speed of movement). Moving on to implementation, I made a custom water mesh (normal planes have immutable resolution which doesn’t work with our algorithm) and a script to generate it. The script works by figuring out how many vertices are needed based on the size of the water and then builds the triangles needed and adds them to an array. The implementation of the iWave algorithm starts precomputing the kernel values and storing them in a lookup table, which we implemented in the second image.

We also wrote functions to evaluate the vertical derivatives of the height grid and implemented a scheme for time stepping. The heart of the algorithm involved us convolving the height values with the kernel to obtain the vertical derivative and then updating the heights according to these vertical derivatives.

Our approach varied from the paper’s in that we had to add damping because The iWave algorithm is highly dependent on the time parameter in the algorithm. Sometimes when the time parameter is too high, the algorithm will be unstable and produce waves that are too large. We prevent these large waves from occuring with a velocity damping term called alpha, but only if time is constant. So, we make sure in our update method that time is constant. A unique decision we made was to increase the longevity of the waves (the amount of time that passes before the waves calm down and become invisible). We did this because we felt like it made the effect look more realistic and visually stimulating.

Some of the problems I encountered for this part were incompatibility issues with Unity (which is why the water simulation is standalone). Some other problems included frame rate lag and inefficiency in our code. In order to fix the lag, I initially tried to use code that adhered to a parallel programming model so I could utilize all the cores on my CPU, but then I realized the much more efficient solution would be to just use my GPU to render the effects in real time. One of the original problems that I encountered was that the default plane in Unity was problematic when trying to make a water mesh because its resolution is not controllable, I solved this by creating a custom mesh that has variable resolution and a script to generate the mesh.

Some of the lessons learned from this part include the importance of algorithms using operations that benefit from hardware acceleration. I learned that the iWave algorithm is successful because it uses convolution and masking instead of FFTs, which makes it very fast on modern computers. I also learned about the tradeoff that Unity gives: many things are very easy to get running like realtime global illumination, but the tradeoff is cross-compatibility and customizability. I also learned the benefits of creating custom objects in programs like Unity (in my custom water mesh) because of the ability to change parameters that are normally hard to access.
